# EP-12909: API Key Authentication for kgateway Traffic Policies

* Issue: [#12909](https://github.com/kgateway-dev/kgateway/issues/12909)

## Background

API key authentication is a common security mechanism for API gateways, allowing clients to authenticate using API keys provided in HTTP headers. Currently, kgateway supports API key authentication in agentgateway policies, but this functionality is missing from the kgateway TrafficPolicy API.

This EP proposes adding API key authentication support to kgateway TrafficPolicy, enabling users to secure their routes with API key validation. The implementation will leverage native API key authentication capabilities for efficient authentication at the proxy level.

## Motivation

### Goals

- Add API key authentication support to `TrafficPolicy` resources for kgateway data plane
- Support API key storage in Kubernetes Secrets as simple string values
- Enable per-route API key authentication configuration
- Provide security features like controlling whether API keys are forwarded to upstream services (default: not forwarded)
- Reject requests without valid API key (strict authentication enforced)
- Support API keys from HTTP headers, query parameters, or cookies
- Support multiple key sources with configurable precedence and fallback behavior

## Implementation Details

### API Changes

The API key authentication configuration is added to `TrafficPolicySpec` in `api/v1alpha1/traffic_policy_types.go`:

```go
// APIKeyAuthentication authenticates users based on a configured API Key.
// +optional
APIKeyAuthentication *APIKeyAuthentication `json:"apiKeyAuthentication,omitempty"`
```

The `APIKeyAuthentication` type is defined directly in `api/v1alpha1/traffic_policy_types.go`:

```go
// APIKeySource defines where to extract the API key from within a single key source.
// Within a single key source, if multiple types are specified, precedence is:
// header > query parameter > cookie. The header is checked first, and only falls back
// to query parameter if the header is not present, then to cookie if both header and query
// are not present.
// +kubebuilder:validation:AtLeastOneOf=header;query;cookie
type APIKeySource struct {
	// header specifies the name of the header that contains the API key.
	// +optional
	// +kubebuilder:validation:MinLength=1
	// +kubebuilder:validation:MaxLength=256
	Header *string `json:"header,omitempty"`

	// query specifies the name of the query parameter that contains the API key.
	// +optional
	// +kubebuilder:validation:MinLength=1
	// +kubebuilder:validation:MaxLength=256
	Query *string `json:"query,omitempty"`

	// cookie specifies the name of the cookie that contains the API key.
	// +optional
	// +kubebuilder:validation:MinLength=1
	// +kubebuilder:validation:MaxLength=256
	Cookie *string `json:"cookie,omitempty"`
}

// +kubebuilder:validation:ExactlyOneOf=secretRef;secretSelector
type APIKeyAuthentication struct {
	// keySources specifies the list of key sources to extract the API key from.
	// Key sources are processed in array order and the first one that successfully
	// extracts a key. Within each key source, if multiple types (header, query, cookie) are
	// specified, precedence is: header > query parameter > cookie.
	//
	// If empty, defaults to a single key source with header "api-key".
	//
	// Example:
	//   keySources:
	//   - header: "X-API-KEY"
	//   - query: "api_key"
	//   - header: "Authorization"
	//     query: "token"
	//     cookie: "auth_token"
	//
	// In this example, the system will:
	// 1. First try header "X-API-KEY"
	// 2. If not found, try query parameter "api_key"
	// 3. If not found, try header "Authorization" (then query "token", then cookie "auth_token" within that key source)
	//
	// +kubebuilder:validation:MinItems=0
	// +kubebuilder:validation:MaxItems=16
	// +optional
	KeySources []APIKeySource `json:"keySources,omitempty"`

	// forwardCredential controls whether the API key is included in the request sent to the upstream.
	// If false (default), the API key is removed from the request before sending to upstream.
	// If true, the API key is included in the request sent to upstream.
	// This applies to all configured key sources (header, query parameter, or cookie).
	// +kubebuilder:default=false
	// +optional
	ForwardCredential *bool `json:"forwardCredential,omitempty"`

	// clientIdHeader specifies the header name to forward the authenticated client identifier.
	// If not specified, the client identifier will not be forwarded in any header.
	// Example: "x-client-id"
	// +optional
	ClientIdHeader *string `json:"clientIdHeader,omitempty"`

	// secretRef references a Kubernetes secret storing a set of API Keys. If there are many keys, 'secretSelector' can be
	// used instead.
	//
	// Each entry in the Secret represents one API Key. The key is an arbitrary identifier.
	// The value is a string, representing the API Key.
	//
	// Example:
	//
	// apiVersion: v1
	// kind: Secret
	// metadata:
	//   name: api-key
	// stringData:
	//   client1: "k-123",
	//   client2: "k-456"
	//
	// +optional
	SecretRef *corev1.LocalObjectReference `json:"secretRef,omitempty"`

	// secretSelector selects multiple secrets containing API Keys. If the same key is defined in multiple secrets, the
	// behavior is undefined.
	//
	// Each entry in the Secret represents one API Key. The key is an arbitrary identifier.
	// The value is a string, representing the API Key.
	//
	// Example:
	//
	// apiVersion: v1
	// kind: Secret
	// metadata:
	//   name: api-key
	// stringData:
	//   client1: "k-123",
	//   client2: "k-456"
	//
	// +optional
	SecretSelector *LabelSelector `json:"secretSelector,omitempty"`
}

// LabelSelector selects resources using label selectors.
type LabelSelector struct {
	// Label selector to select the target resource.
	// +required
	MatchLabels map[string]string `json:"matchLabels"`
}
```

### Secret Format

API keys are stored in Kubernetes Secrets as simple string values. Each entry in the Secret represents one API Key, where:
- The secret key name (e.g., `user`) becomes the client identifier that can be used for authorization or logging purposes
- The value is a string representing the API Key itself

**Example:**
```yaml
apiVersion: v1
kind: Secret
metadata:
  name: api-keys
stringData:
  user: "real-key"
  service: "service-key-123"
  client1: "k-123"
  client2: "k-456"
```

### Proxy Configuration

The implementation will configure the API key authentication filter at the proxy level:

```json
{
  "name": "api_key_auth",
  "typed_config": {
    "@type": "type.googleapis.com/api_key_auth.v3.ApiKeyAuth",
    "credentials": [
      {
        "key": "real-key",
        "client": "user"
      }
    ],
    "key_sources": [
      {
        "header": "X-API-KEY"
      },
      {
        "query": "api_key"
      },
      {
        "header": "Authorization",
        "query": "token",
        "cookie": "auth_token"
      }
    ],
    "forwarding": {
      "header": "x-client-id",  // Configurable via clientIdHeader field (optional)
      "hide_credentials": true   // Set to !forwardCredential (defaults to true when forwardCredential is false)
    }
  }
}
```

### Translator Implementation

The translator will need to:

1. **Process TrafficPolicy with API key authentication:**
   - Extract API key configuration from `TrafficPolicySpec`
   - Resolve secrets using `secretRef` or `secretSelector`
   - Parse secret entries (string values only)
   - Build API key auth filter configuration

2. **Secret Resolution:**
   - For `secretRef`: Fetch single secret by name
   - For `secretSelector`: Fetch all secrets matching labels in the policy namespace
   - Handle missing secrets with appropriate error reporting

3. **Filter Configuration:**
   - Map API keys from secrets to credentials format
   - Configure `key_sources` array from the `keySources` field
   - Each `APIKeySource` maps to a key source in the proxy configuration
   - If `keySources` is empty, default to a single key source with header "api-key"
   - Within each key source, set header, query, and/or cookie based on the `APIKeySource` fields
   - Key sources are processed in array order (first successful extraction wins)
   - Within a single key source, header is checked first, then query, then cookie (fallback behavior)
   - Set `forwarding.header` based on `clientIdHeader` (optional, only set if specified)
   - Set `forwarding.hide_credentials` based on `forwardCredential` (inverted: `hide_credentials = !forwardCredential`, defaults to true)
   - Apply per-route configuration for route-level policies
   - The API key auth filter will reject requests without valid API keys (strict authentication enforced)

### Example Usage

**TrafficPolicy targeting an HTTPRoute with header-based API key (default):**
```yaml
apiVersion: gateway.kgateway.dev/v1alpha1
kind: TrafficPolicy
metadata:
  name: api-key-auth
  namespace: default
spec:
  targetRefs:
  - name: my-api-route
    kind: HTTPRoute
    group: gateway.networking.k8s.io
  apiKeyAuthentication:
    # keySources is empty, defaults to header "api-key"
    # forwardCredential defaults to false, so API key will be removed from request
    secretSelector:
      matchLabels:
        type: api-keys
```

**TrafficPolicy with explicit header key source:**
```yaml
apiVersion: gateway.kgateway.dev/v1alpha1
kind: TrafficPolicy
metadata:
  name: api-key-auth-header
  namespace: default
spec:
  targetRefs:
  - name: my-api-route
    kind: HTTPRoute
    group: gateway.networking.k8s.io
  apiKeyAuthentication:
    keySources:
    - header: "x-api-key"
    # forwardCredential defaults to false, so API key will be removed from request
    secretRef:
      name: api-keys
```

**TrafficPolicy with multiple key sources (header, then query):**
```yaml
apiVersion: gateway.kgateway.dev/v1alpha1
kind: TrafficPolicy
metadata:
  name: api-key-auth-multiple
  namespace: default
spec:
  targetRefs:
  - name: my-api-route
    kind: HTTPRoute
    group: gateway.networking.k8s.io
  apiKeyAuthentication:
    keySources:
    - header: "X-API-KEY"
    - query: "api_key"
    # forwardCredential defaults to false, so API key will be removed from request
    secretRef:
      name: api-keys
```

**TrafficPolicy with key source containing multiple types (header with fallback to query and cookie):**
```yaml
apiVersion: gateway.kgateway.dev/v1alpha1
kind: TrafficPolicy
metadata:
  name: api-key-auth-fallback
  namespace: default
spec:
  targetRefs:
  - name: my-api-route
    kind: HTTPRoute
    group: gateway.networking.k8s.io
  apiKeyAuthentication:
    keySources:
    - header: "Authorization"
      query: "token"
      cookie: "auth_token"
    # forwardCredential defaults to false, so API key will be removed from request
    secretRef:
      name: api-keys
```

**TrafficPolicy with custom client ID header:**
```yaml
apiVersion: gateway.kgateway.dev/v1alpha1
kind: TrafficPolicy
metadata:
  name: api-key-auth-custom-header
  namespace: default
spec:
  targetRefs:
  - name: my-api-route
    kind: HTTPRoute
    group: gateway.networking.k8s.io
  apiKeyAuthentication:
    keySources:
    - header: "x-api-key"
    # forwardCredential defaults to false, so API key will be removed from request
    clientIdHeader: "x-authenticated-user"  # Custom header for client identity
    secretRef:
      name: api-keys
```

**Secret with API keys:**
```yaml
apiVersion: v1
kind: Secret
metadata:
  name: api-keys
  namespace: default
  labels:
    type: api-keys
stringData:
  user: "real-key"
  service: "service-key-123"
  client1: "k-123"
  client2: "k-456"
```

### Configuration

No additional configuration changes are required. The feature uses existing Kubernetes Secret resources and follows standard TrafficPolicy attachment patterns.

### Plugin

The implementation will be added to the traffic policy plugin system:

- **Location**: `internal/kgateway/extensions2/plugins/trafficpolicy/`
- **Responsibilities**:
  - Process `APIKeyAuthentication` field from TrafficPolicy
  - Resolve and parse secrets
  - Generate API key auth filter configuration
  - Apply filter to appropriate routes/listeners

### Controllers

No new controllers are required. Existing TrafficPolicy controllers will handle the new field automatically through the standard reconciliation process.

### Translator and Proxy Syncer

The translator will need updates to:

1. **Filter Chain Construction:**
   - Add API key auth filter to HTTP filter chain when API key authentication is configured
   - Position filter appropriately in the chain (before routing, after request ID)

2. **Route Configuration:**
   - Support per-route API key auth configuration via `ApiKeyAuthPerRoute`
   - Handle policy attachment at Gateway, Listener, and Route levels

3. **Secret Watching:**
   - Watch for secret changes and update proxy configuration accordingly
   - Handle secret deletion gracefully

### Reporting

Status reporting should include:

- Validation errors for missing or invalid secrets
- Errors for invalid API key entries in secrets
- Warnings for duplicate API keys across multiple secrets

## Test Plan

### Unit Tests

- Test secret parsing (string format only)
- Test secret resolution (secretRef and secretSelector)
- Test filter configuration generation with clientIdHeader
- Test validation logic for API key authentication fields
- Test clientIdHeader default value and custom configuration

### Integration Tests

- Test TrafficPolicy with API key authentication on HTTPRoute
- Test secret updates and filter reconfiguration
- Test policy attachment at different levels (Gateway, Route)
- Test authentication behavior (reject requests without valid API key)

### End-to-End Tests

- Test successful authentication with valid API key
- Test rejection of requests without API key
- Test rejection of requests with invalid API key
- Test `forwardCredential` functionality (verify API key removed from upstream when false, included when true)
- Test key sources from header, query parameter, and cookie
- Test multiple key sources with array order precedence
- Test key source with multiple types (header with fallback to query/cookie)
- Test default behavior when keySources is empty (defaults to header "api-key")
- Test clientIdHeader configuration (default empty and custom values)
- Test client identity forwarding in custom headers
- Test multiple API keys from different secrets
- Test secret selector with label matching

## Alternatives

### Alternative 1: Use ext_authz Instead of Native API Key Filter

**Pros:**
- Consistent with existing ext_authz infrastructure
- Supports complex authorization logic

**Cons:**
- Requires external auth service
- Higher latency (external call)
- More complex deployment
- Less efficient than native filter

**Decision:** Use native API key auth filter for better performance and simpler deployment.

## References

- [Envoy API Key Auth Filter](https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/http/api_key_auth/v3/api_key_auth.proto)
- [Gloo Edge API Key Auth](https://docs.solo.io/gloo-edge/latest/guides/security/auth/extauth/apikey_auth/)
- [Agentgateway API Key Auth Implementation](https://github.com/kgateway-dev/kgateway/blob/main/pkg/agentgateway/plugins/traffic_plugin.go#L595)

